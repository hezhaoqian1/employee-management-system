# 员工管理系统面试视频录制教程（超详细版）

## 📋 录制前准备清单

### 🔧 技术准备
- [ ] MySQL数据库运行中，数据已导入完成
- [ ] Spring Boot应用启动成功，控制台无报错
- [ ] 浏览器打开 `http://localhost:8080/swagger-ui.html` 确认可访问
- [ ] 关闭所有无关程序和通知
- [ ] 调整屏幕分辨率到1920x1080或1366x768
- [ ] 确保网络稳定

### 🎥 录制准备
- [ ] 录屏软件设置好（推荐OBS Studio或Bandicam）
- [ ] 麦克风测试完成，音量适中
- [ ] 桌面整理干净，只保留必要窗口
- [ ] 准备计时器，总时长控制在8分钟内

---

## 🎬 第一部分：开场和项目介绍（45秒）

### 📺 镜头：桌面显示项目文件夹

**【操作1】：** 确保桌面显示项目文件夹`employee-management-system`

**【说话内容1】：**
> "大家好，我是XXX。今天为大家演示我完成的Spring Boot企业员工管理系统。"

**【停顿2秒，鼠标指向项目文件夹】**

**【说话内容2】：**
> "这个项目使用了Spring Boot + MyBatis + MySQL的技术栈，主要实现了面试要求的三个核心功能：组织架构管理、员工信息管理，以及并发批量短信发送。"

**【停顿2秒】**

**【说话内容3】：**
> "项目采用标准的企业级开发规范，包含了完整的API文档和异常处理机制。"

---

## 🎬 第二部分：数据库设计展示（1分钟）

### 📺 镜头：打开数据库设计文件

**【操作1】：** 双击打开 `database_design.sql` 文件

**【说话内容1】：**
> "首先看一下数据库设计，这是我花时间仔细设计的核心架构。"

**【操作2】：** 滚动到organization表定义（大约在文件的第15-30行）

**【说话内容2】：**
> "organization表是核心的设计亮点。"

**【操作3】：** 鼠标指向parent_id字段

**【说话内容3】：**
> "我使用parent_id字段建立父子关系，"

**【操作4】：** 鼠标指向level字段

**【说话内容4】：**
> "level字段记录层级深度，"

**【操作5】：** 鼠标指向full_path字段

**【说话内容5】：**
> "full_path字段存储完整路径，支持像'集团总部/杭州分公司/技术部'这样的树形结构。这种设计既支持无限层级，又能高效查询。"

**【停顿2秒】**

**【操作6】：** 滚动到employee表

**【说话内容6】：**
> "employee表通过organization_id与组织表关联，"

**【操作7】：** 滚动到sms_record表

**【说话内容7】：**
> "sms_record表专门设计用于批量短信的状态追踪，支持并发处理和完整的发送记录管理。"

---

## 🎬 第三部分：架构设计讲解（45秒）

### 📺 镜头：展示代码结构

**【操作1】：** 切换到IDE或文件管理器，展开项目结构到 `src/main/java/com/company/ems`

**【说话内容1】：**
> "代码架构方面，我严格按照企业级三层架构设计。"

**【操作2】：** 鼠标指向controller包

**【说话内容2】：**
> "Controller层专注处理HTTP请求，"

**【操作3】：** 鼠标指向service包

**【说话内容3】：**
> "Service层处理核心业务逻辑，包含树形结构算法和并发处理，"

**【操作4】：** 鼠标指向mapper包

**【说话内容4】：**
> "Mapper层负责数据访问，使用MyBatis进行ORM映射。"

**【操作5】：** 鼠标指向config包

**【说话内容5】：**
> "另外还有配置层，包括异步处理配置和Swagger文档配置，体现了完整的企业级开发规范。"

---

## 🎬 第四部分：核心功能演示（5分钟30秒）

### 📺 镜头：切换到Swagger页面

**【操作1】：** 点击浏览器标签，确保显示 `http://localhost:8080/swagger-ui.html`

**【说话内容1】：**
> "现在通过Swagger API文档来演示系统功能。我集成了Swagger进行API文档管理，这在团队协作中非常重要。"

---

### 🎯 功能演示1：组织架构管理（2分钟）

#### 1.1 查询组织架构树（30秒）

**【操作1】：** 点击 "1. 组织机构管理" 区域展开

**【说话内容1】：**
> "首先演示组织架构管理的核心功能。"

**【操作2】：** 点击 `GET /api/organizations/tree` 接口

**【操作3】：** 点击蓝色的 "Try it out" 按钮

**【说话内容2】：**
> "这个接口会返回完整的组织架构树形结构。"

**【操作4】：** 点击 "Execute" 按钮

**【等待2秒加载】**

**【说话内容3】：**
> "可以看到，系统成功返回了树形结构数据。"

**【操作5】：** 滚动查看Response body，鼠标指向children字段

**【说话内容4】：**
> "注意这里的children字段，这是我用递归算法实现的。每个节点都包含了完整的子节点信息和员工数量统计。这个算法可以处理任意深度的组织架构。"

#### 1.2 新增组织机构（45秒）

**【操作1】：** 向上滚动，点击 `POST /api/organizations` 接口

**【操作2】：** 点击 "Try it out" 按钮

**【说话内容1】：**
> "现在演示新增组织功能。"

**【操作3】：** 在Request body文本框中，清空内容并输入：
```json
{
  "name": "市场营销部",
  "parentId": 2,
  "description": "负责市场推广、品牌建设和销售支持",
  "status": 1,
  "sortOrder": 1
}
```

**【说话内容2】：**
> "我在杭州分公司下新建一个市场营销部，parentId设为2表示父组织是杭州分公司。"

**【操作4】：** 点击 "Execute" 按钮

**【等待2秒】**

**【说话内容3】：**
> "可以看到系统返回了新创建记录的完整信息，包括自动生成的组织编码和计算好的层级路径。新增成功。"

#### 1.3 修改组织信息（45秒）

**【操作1】：** 向上滚动，点击 `PUT /api/organizations/{id}` 接口

**【操作2】：** 点击 "Try it out" 按钮

**【操作3】：** 在id参数框中输入刚才返回的ID（比如6）

**【操作4】：** 在Request body中输入：
```json
{
  "id": 6,
  "name": "市场营销中心",
  "parentId": 2,
  "description": "负责市场推广、品牌建设、销售支持和客户关系管理",
  "status": 1,
  "sortOrder": 1
}
```

**【说话内容1】：**
> "演示修改功能，我把刚才的'市场营销部'升级为'市场营销中心'，并扩展了职责描述。"

**【操作5】：** 点击 "Execute" 按钮

**【说话内容2】：**
> "修改成功，返回了更新后的完整信息。"

---

### 🎯 功能演示2：员工管理（2分钟）

#### 2.1 查询员工列表（30秒）

**【操作1】：** 点击 "2. 员工管理" 区域展开

**【操作2】：** 点击 `GET /api/employees` 接口

**【操作3】：** 点击 "Try it out" 按钮

**【说话内容1】：**
> "员工管理模块，首先查看所有员工列表。"

**【操作4】：** 点击 "Execute" 按钮

**【说话内容2】：**
> "可以看到所有员工的详细信息，包括姓名、邮箱、电话、所属部门等，每个员工都关联了对应的组织架构信息。"

#### 2.2 新增员工（45秒）

**【操作1】：** 向上滚动，点击 `POST /api/employees` 接口

**【操作2】：** 点击 "Try it out" 按钮

**【操作3】：** 在Request body中输入：
```json
{
  "name": "王小明",
  "email": "wangxiaoming@company.com",
  "phone": "13888888888",
  "organizationId": 4,
  "position": "Java开发工程师",
  "hireDate": "2024-07-19",
  "status": 1
}
```

**【说话内容1】：**
> "演示新增员工功能，我在技术部新增一个Java开发工程师王小明。organizationId设为4，表示分配到技术部。"

**【操作4】：** 点击 "Execute" 按钮

**【说话内容2】：**
> "新增成功，系统返回了包含自动生成ID的完整员工信息。"

#### 2.3 修改员工信息（45秒）

**【操作1】：** 向上滚动，点击 `PUT /api/employees/{id}` 接口

**【操作2】：** 点击 "Try it out" 按钮

**【操作3】：** 在id参数中输入刚才返回的员工ID

**【操作4】：** 在Request body中输入：
```json
{
  "id": 6,
  "name": "王小明",
  "email": "wangxiaoming@company.com",
  "phone": "13888888888",
  "organizationId": 4,
  "position": "高级Java开发工程师",
  "hireDate": "2024-07-19",
  "status": 1
}
```

**【说话内容1】：**
> "演示修改员工信息，我把王小明的职位从'Java开发工程师'晋升为'高级Java开发工程师'。"

**【操作5】：** 点击 "Execute" 按钮

**【说话内容2】：**
> "修改成功，职位信息已更新。"

---

### 🎯 功能演示3：并发短信发送（1分钟30秒）

#### 3.1 发送批量短信（45秒）

**【操作1】：** 点击 "3. 短信管理" 区域展开

**【操作2】：** 点击 `POST /api/sms/batch` 接口

**【操作3】：** 点击 "Try it out" 按钮

**【说话内容1】：**
> "现在演示最核心的并发短信发送功能。这是我设计的技术亮点。"

**【操作4】：** 在Request body中输入：
```json
{
  "employeeIds": [1, 2, 3, 4, 5, 6],
  "content": "【公司通知】欢迎新同事王小明加入技术部，大家相互认识一下！",
  "batchId": "WELCOME_BATCH_001"
}
```

**【说话内容2】：**
> "我设置向所有员工包括新员工发送欢迎通知。这里用到了两层并发设计：Spring的@Async让整个批次异步执行，CompletableFuture让每条短信并发发送。"

**【操作5】：** 点击 "Execute" 按钮

**【说话内容3】：**
> "任务提交成功，系统会在后台并发处理所有短信发送。"

#### 3.2 查看发送状态（45秒）

**【操作1】：** 向下滚动，点击 `GET /api/sms/records/{batchId}` 接口

**【操作2】：** 点击 "Try it out" 按钮

**【操作3】：** 在batchId参数中输入：WELCOME_BATCH_001

**【说话内容1】：**
> "查看这个批次的详细发送状态。"

**【操作4】：** 点击 "Execute" 按钮

**【等待3秒让系统处理】**

**【说话内容2】：**
> "可以看到每条短信的发送状态，包括发送时间、成功失败状态。注意发送时间几乎是同时的，这就是并发处理的效果。如果是传统的循环发送，6条短信需要6-18秒，现在只需要1-3秒。"

**【操作5】：** 鼠标指向sendTime字段

**【说话内容3】：**
> "这种并发设计在实际生产环境中可以将发送效率提升几十倍。"

---

## 🎬 第五部分：核心需求代码实现讲解（3分钟）

### 📺 镜头：切换到IDE，逐一展示HR要求的代码实现

**【说话内容1】：**
> "现在我来逐一展示HR提出的三个核心需求的代码实现。"

---

#### 5.1 需求1：多层组织架构管理（1分30秒）

**【操作1】：** 打开 `OrganizationServiceImpl.java`，定位到 `buildTree` 方法
**【说话内容1】：**
> "第一个需求：具备多层结构的机构管理，比如杭州市/拱墅区这样的层级。我的实现有三个核心部分。"

**【操作2】：** 鼠标指向 `buildTree` 方法中的关键代码
**【说话内容2】：**
> "首先是查询算法：这个递归方法可以构建任意深度的树形结构。先找根节点，再递归查找子节点。"

**【操作3】：** 滚动到 `create` 方法
**【说话内容3】：**
> "第二是新增逻辑：看这里的create方法，新增时会自动生成组织编码，计算层级level，构建完整路径full_path。"

**【操作4】：** 指向编码生成和路径构建的代码
**【说话内容4】：**
> "组织编码用中文转拼音算法生成，路径会自动拼接父级路径，这样'/杭州市/拱墅区/技术部'这样的层级关系就建立了。"

**【操作5】：** 滚动到 `update` 方法
**【说话内容5】：**
> "第三是修改逻辑：修改时会重新计算路径，并递归更新所有子节点的路径，保证数据一致性。"

**【操作6】：** 切换到数据库设计，指向 organization 表结构
**【说话内容6】：**
> "数据库设计支持这个逻辑：parent_id建立父子关系，level记录层级深度，full_path存储完整路径。"

---

#### 5.2 需求2：员工CRUD管理（45秒）

**【操作4】：** 打开 `EmployeeServiceImpl.java`，定位到主要的CRUD方法
**【说话内容4】：**
> "第二个需求：员工的列表、详情、新增、修改功能。我实现了完整的CRUD操作。"

**【操作5】：** 鼠标指向 `create` 方法中的员工编号生成逻辑
**【说话内容5】：**
> "这里有个技术亮点，员工编号自动生成：EMP+日期+随机数，确保唯一性。新增时会自动关联组织架构，查询时会带出完整的组织信息。"

**【操作6】：** 指向 `update` 方法
**【说话内容6】：**
> "修改功能支持部分字段更新，并且会自动处理关联关系的维护。"

---

#### 5.3 需求3：并发短信发送（2分钟）

**【操作7】：** 打开 `SmsServiceImpl.java`，定位到 `sendBatchSms` 方法
**【说话内容7】：**
> "第三个需求：并发向员工发送短信。这是技术难点，我设计了完整的批次处理和并发发送机制。"

**【操作8】：** 鼠标指向 `@Async` 注解
**【说话内容8】：**
> "第一层异步：方法级别的@Async异步，让整个批次发送不阻塞调用方。"

**【操作9】：** 指向批次记录创建的代码部分
**【说话内容9】：**
> "首先为每个员工创建短信记录，状态设为0待发送，这样可以追踪每条短信的发送状态。"

**【操作10】：** 鼠标指向 `CompletableFuture.runAsync` 部分
**【说话内容10】：**
> "第二层异步：内部用CompletableFuture为每条短信创建独立的异步任务，实现真正的并发发送。"

**【操作11】：** 指向 `CompletableFuture.allOf` 这一行
**【说话内容11】：**
> "这一行是关键，allOf等待所有短信发送完成，确保数据一致性。传统串行发送6条短信需要6秒，现在并发只需要1-2秒。"

**【操作12】：** 滚动到 `sendSingleSms` 方法
**【说话内容12】：**
> "底层发送逻辑：这里我用模拟的方式演示。现实中这里会调用阿里云短信API、腾讯云短信API或运营商短信网关。"

**【操作13】：** 指向 `Thread.sleep` 和随机成功率的代码
**【说话内容13】：**
> "模拟了1-3秒的网络延迟和90%的成功率，真实还原了短信发送的网络环境。每条短信的状态都会实时更新到数据库。"


---

## 🎬 第六部分：结束总结（30秒）

**【说话内容1】：**
> "总结一下，这个系统完整实现了面试要求的三个核心能力：数据库设计能力、框架集成能力，以及并发处理能力。"

**【停顿2秒】**

**【说话内容2】：**
> "所有的CRUD操作都已演示完成，包括组织架构的新增修改、员工信息的新增修改，以及并发短信发送的完整流程。"

**【停顿2秒】**

**【说话内容3】：**
> "整个系统采用了企业级的开发标准，代码结构清晰，具备良好的扩展性和维护性。谢谢大家，演示完毕。"

---

## 🚨 应急预案和注意事项

### 如果接口调用失败：
**说**："让我检查一下应用状态..." 然后检查Spring Boot控制台

### 如果返回数据异常：
**说**："数据可能还在处理中，我们可以看到接口本身是正常工作的..."

### 如果页面卡顿：
**说**："让我刷新一下页面..." 然后F5刷新

### 演示节奏控制：
- 每次点击后停顿2-3秒
- 查看结果时停顿5秒让HR看清楚
- 说话语速适中，吐字清晰
- 总时长严格控制在8分钟内

### 录制技巧：
- 开始录制前深呼吸，保持自信
- 如果说错话，可以重新录制该段落
- 鼠标移动要平稳，避免晃动
- 确保每个操作都清晰可见

---

## 📋 完整测试用例参考

### 新增组织测试数据：
```json
{
  "name": "市场营销部",
  "parentId": 2,
  "description": "负责市场推广、品牌建设和销售支持",
  "status": 1,
  "sortOrder": 1
}
```

### 修改组织测试数据：
```json
{
  "id": 6,
  "name": "市场营销中心", 
  "parentId": 2,
  "description": "负责市场推广、品牌建设、销售支持和客户关系管理",
  "status": 1,
  "sortOrder": 1
}
```

### 新增员工测试数据：
```json
{
  "name": "王小明",
  "email": "wangxiaoming@company.com",
  "phone": "13888888888",
  "organizationId": 4,
  "position": "Java开发工程师",
  "hireDate": "2024-07-19",
  "status": 1
}
```

### 修改员工测试数据：
```json
{
  "id": 6,
  "name": "王小明",
  "email": "wangxiaoming@company.com",
  "phone": "13888888888", 
  "organizationId": 4,
  "position": "高级Java开发工程师",
  "hireDate": "2024-07-19",
  "status": 1
}
```

### 短信发送测试数据：
```json
{
  "employeeIds": [1, 2, 3, 4, 5, 6],
  "content": "【公司通知】欢迎新同事王小明加入技术部，大家相互认识一下！",
  "batchId": "WELCOME_BATCH_001"
}
```

---

**🎯 记住：展现技术深度、工程能力、和解决实际问题的思维！面试官看重的是你的技术理解和实际编码能力！**